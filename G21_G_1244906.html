<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Computergraphik ist cool, aber auf keinen Fall ist der Aufwand größer als 5 CP!!!</title>

    <!-- Hier steht der Quellcode des Vertex-Shaders -->
    <script id="vertex-shader" type="x-shader/x-vertex">

      // Vars get filled for each vertex
attribute vec4 vPosition;   // Objektkoordinate des Vertex
attribute vec3 vNormal;     // Normale des Vertex (in Objektkoordinaten)
attribute vec4 vColor;      // Farbe des Vertex (falls keine Beleuchtungsberechnung)
varying vec4 fColor;        // Vertex-Shader calculates color value and passes to fragment shader

// Uniform -> Value gets calculated by CPU and passed to shader
uniform bool lighting;

uniform vec4 lightPosition;

uniform vec4 diffuseProduct;
uniform vec4 ambientProduct;
uniform vec4 specularProduct;
uniform float materialShininess;


uniform mat4 modelMatrix;       // Objektkoord -> Weltkoord
uniform mat4 viewMatrix;        // Weltkoord -> Kamerakoord
uniform mat4 projectionMatrix;  // Kamerakoord -> Clippingkoord
uniform mat4 normalMatrix;      // Normale -> Kamerakoord


void main()
{
    if(lighting) {
        vec3 pos = (viewMatrix * modelMatrix * vPosition).xyz; // calc view-coord of point
        vec3 light = (viewMatrix * lightPosition).xyz; // calc view-coord of light
        vec3 L = normalize( light - pos ); // Normalized Vector from point to light

        // Normale am Eckpunkt in Weltkoordinaten berechnen
        vec3 N = normalize((normalMatrix * vec4(vNormal, 0.0)).xyz);
        
        // Berechnung der diffusen Beleuchtung nach den Formeln von Phong
        float Kd = max(dot(L, N), 0.0);
        vec4 diffuse = Kd * diffuseProduct;
        
        // Ambient Light (influenced by objects color)
        vec4 ambient = ambientProduct;

        // Specular Light
        vec3 E = normalize(-pos);
        vec3 H = normalize(L+E);

        float Ks = pow(max(dot(N, H), 0.0), materialShininess);
        vec4 specular = Ks * specularProduct;

        if(dot(L, N) < 0.0) {
            specular = vec4(0.0, 0.0, 0.0, 1.0);
        }

        // Combined color for shader
        //fColor = diffuse + ambientProduct + specular;
        fColor = diffuse + ambient + specular;
    } else {
        // No lighting done in shader -> use value provided by cpu
        fColor = vColor;
    }

    // Translate coordinate into clipping coordinate and pass it to gl_position
    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vPosition;
}

    </script>

    <!-- und hier der Quellcode für den Fragment-Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">

    // Bitgröße von float definieren
    precision mediump float;

    // Werte, die vom Vertex-Shader übergeben und in der 
    // Rasterisierung für das aktuelle Fragment errechnet wurden

    // Farbwert für das Fragment
    varying vec4 fColor;

    void main()
    {
        // wie jeder Fragment-Shader muss der Farbwert des
        // Fragments bestimmt und in die vordefinierte Variable
        // gl_FragColor geschrieben werden

        // wir übernehmen hier einfach den übergebenen Wert	  
        gl_FragColor = fColor;
    }

    </script>

    <!-- in diesem Schritt stehen ein paar Hilfsfunktionen zu WebGL -->
    <script type="text/javascript" src="./Common/webgl-utils.js"></script>

    <!-- dieses Skript enthält Funktionen, um die Shader zu
    kompilieren und zu einem Programm zu linken -->
    <script type="text/javascript" src="./Common/initShaders.js"></script>

    <!-- dieses Skript enthält Hilfsfunktionen für das Rechnen mit
    Vektoren und Matrizen in Javascript -->
    <script type="text/javascript" src="./Common/MV.js"></script>

    <!-- dies ist unser eigentliches Skript, in dem der Code für
    die "CPU-Seite" steht -->
    <script type="text/javascript" src="G21_G_1244906.js"></script>
  </head>

  <body style = "background-color: rgb(30, 30, 40); color: white">
    
    <div>
      <label id="fps">FPS: ## (alle ## Frames berechnet)</label>
    </div>

    <div>
      <select id="Cameralist" size="5" style="overflow: hidden">
        <option selected value=0>Cam 1: Original</option> 
        <option value=1>Cam 2: x-axis</option> 
        <option value=2>Cam 3: y-axis</option> 
        <option value=3>Cam 4: z-axis</option> 
        <option value=4>Cam 5: pyramids touch tips ❤️</option> 
      </select>
    </div>

    <div>
      <p>
        Rotation:
        <button id = "ButtonX">Rotate X</button>
        <button id = "ButtonY">Rotate Y</button>
        <button id = "ButtonZ">Rotate Z</button>
        <button id = "ButtonT">Rotate On/Off</button>
      </p>
    </div>

    <div>
      <p>
        Camera Settings:
        <button id = "ButtonFOV">Change FOV (current = 60)</button>
        <button id = "ButtonAspect">Change Aspect Ratio (current = 1:1)</button>
        <button id = "ButtonNear">Change Near Clipping Plane (current = 0.01)</button>
      </p>
    </div>

    <div>
      <p>
        Ambient Light Intensity:
        <input id="SliderAmbient" type="range" min="0" max="100" value="0">
      </p>
    </div>

    <div>
      <p>
        Specular Light Intensity (Shininess):
        <input id="SliderShiny" type="range" min="0" max="100" value="0">
      </p>
    </div>

    <!-- Hier wird der Bereich im Browser angelegt, in den gezeichnet wird -->

    <img id="rr" src="8bit.gif" width="40%" style = "display:none">
    
    <canvas id="gl-canvas" width="600" height="600" style="display:block">
  The HTML 5 Canvas is not supported by your browser. Please use another browser to view this page.
    </canvas>

    <div>
      <button id = "hehe">Click me</button>
    </div>

    <audio id="aud" controls style="visibility: hidden;">
      <source src="8bit.mp3" type="audio/mpeg">
    </audio>

  </body>
</html>
